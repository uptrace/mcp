// Code generated by oapi-codegen. DO NOT EDIT.

package uptraceapi

import (
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
)

type TimeStart = struct {
	TimeStart_OneOf *TimeStart_OneOf `json:"-"`
}

type TimeEnd = struct {
	TimeEnd_OneOf *TimeEnd_OneOf `json:"-"`
}

type Limit = int32

type ListSpansQuery struct {
	// TimeStart Start time as unix milliseconds or RFC3339 timestamp.
	TimeStart TimeStart `json:"time_start"`

	// TimeEnd End time as unix milliseconds or RFC3339 timestamp.
	TimeEnd TimeEnd `json:"time_end"`

	// TraceID Filter spans by trace ID.
	TraceID *string `json:"trace_id,omitempty"`

	// ID Filter spans by span ID.
	ID *int `json:"id,omitempty"`

	// ParentID Filter spans by parent span ID.
	ParentID *int `json:"parent_id,omitempty"`

	// Limit Limit number of results.
	Limit *Limit `json:"limit,omitempty"`
}

func (l ListSpansQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.TimeStart).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TimeStart", err)
		}
	}
	if v, ok := any(l.TimeEnd).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TimeEnd", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ListSpanGroupsQuery struct {
	// TimeStart Start time as unix milliseconds or RFC3339 timestamp.
	TimeStart TimeStart `json:"time_start"`

	// TimeEnd End time as unix milliseconds or RFC3339 timestamp.
	TimeEnd TimeEnd `json:"time_end"`

	// Query Aggregate spans using the specified query.
	Query *string `json:"query,omitempty"`

	// Limit Limit number of results.
	Limit *Limit `json:"limit,omitempty"`

	// Search Search for spans containing option1 or option2.
	Search *string `json:"search,omitempty"`

	// DurationGte Duration greater than or equal to N (microseconds).
	DurationGte *int64 `json:"duration_gte,omitempty"`

	// DurationLt Duration less than N (microseconds).
	DurationLt *int64 `json:"duration_lt,omitempty"`
}

func (l ListSpanGroupsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.TimeStart).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TimeStart", err)
		}
	}
	if v, ok := any(l.TimeEnd).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TimeEnd", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}
