// Code generated by oapi-codegen. DO NOT EDIT.

package uptraceapi

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
)

type AnnotationCreateRequest struct {
	// Name Annotation name.
	Name string `json:"name" validate:"required"`

	// Description Annotation description text in Markdown format.
	Description *string `json:"description,omitempty"`

	// Color Color to be used in charts.
	Color *string `json:"color,omitempty"`

	// Attrs Key-value metadata.
	Attrs map[string]string `json:"attrs,omitempty"`

	// Fingerprint Unique string used for deduplication.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Time Overrides annotation time in RFC3339 format.
	Time *time.Time `json:"time,omitempty"`
}

func (a AnnotationCreateRequest) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type Error struct {
	Code    string `json:"code" validate:"required"`
	Message string `json:"message" validate:"required"`
}

func (e Error) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

func (s Error) Error() string {
	return "unmapped client error"
}

// SeedDataRequest Fixture data used to create, update, or delete resources by key.
type SeedDataRequest struct {
	Users         []UserFixture         `json:"users,omitempty"`
	UserTokens    []UserTokenFixture    `json:"userTokens,omitempty"`
	Orgs          []OrgFixture          `json:"orgs,omitempty"`
	OrgUsers      []OrgUserFixture      `json:"orgUsers,omitempty"`
	Projects      []ProjectFixture      `json:"projects,omitempty"`
	ProjectTokens []ProjectTokenFixture `json:"projectTokens,omitempty"`
	ProjectUsers  []ProjectUserFixture  `json:"projectUsers,omitempty"`
}

func (s SeedDataRequest) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range s.Users {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Users[%d]", i), err)
			}
		}
	}
	for i, item := range s.UserTokens {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("UserTokens[%d]", i), err)
			}
		}
	}
	for i, item := range s.Orgs {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Orgs[%d]", i), err)
			}
		}
	}
	for i, item := range s.OrgUsers {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OrgUsers[%d]", i), err)
			}
		}
	}
	for i, item := range s.Projects {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Projects[%d]", i), err)
			}
		}
	}
	for i, item := range s.ProjectTokens {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("ProjectTokens[%d]", i), err)
			}
		}
	}
	for i, item := range s.ProjectUsers {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("ProjectUsers[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// LinkDataRequest Links existing resources to fixture keys.
type LinkDataRequest struct {
	Orgs          []LinkFixture `json:"orgs,omitempty"`
	OrgUsers      []LinkFixture `json:"orgUsers,omitempty"`
	Projects      []LinkFixture `json:"projects,omitempty"`
	ProjectTokens []LinkFixture `json:"projectTokens,omitempty"`
}

func (l LinkDataRequest) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.Orgs {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Orgs[%d]", i), err)
			}
		}
	}
	for i, item := range l.OrgUsers {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OrgUsers[%d]", i), err)
			}
		}
	}
	for i, item := range l.Projects {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Projects[%d]", i), err)
			}
		}
	}
	for i, item := range l.ProjectTokens {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("ProjectTokens[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserFixture struct {
	// Key Unique fixture key.
	Key string `json:"key" validate:"required"`

	// Name Display name.
	Name  string        `json:"name" validate:"required"`
	Email runtime.Email `json:"email" validate:"required"`

	// Password Plain-text password (hashed by Uptrace).
	Password string `json:"password" validate:"required"`
}

func (u UserFixture) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(u.Key, "required"); err != nil {
		errors = errors.Append("Key", err)
	}
	if err := typesValidator.Var(u.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.Password, "required"); err != nil {
		errors = errors.Append("Password", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserTokenFixture struct {
	Key string `json:"key" validate:"required"`

	// UserKey References users.key.
	UserKey string `json:"userKey" validate:"required"`
	Token   string `json:"token" validate:"required"`

	// Name Human-readable token name.
	Name *string `json:"name,omitempty"`
}

func (u UserTokenFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type OrgFixture struct {
	Key         string  `json:"key" validate:"required"`
	Name        string  `json:"name" validate:"required"`
	Description *string `json:"description,omitempty"`
}

func (o OrgFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(o))
}

type OrgUserFixture struct {
	Key string `json:"key" validate:"required"`

	// OrgKey References orgs.key.
	OrgKey string `json:"orgKey" validate:"required"`

	// UserKey References users.key.
	UserKey string             `json:"userKey" validate:"required"`
	Role    OrgUserFixtureRole `json:"role" validate:"required"`
}

func (o OrgUserFixture) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Key, "required"); err != nil {
		errors = errors.Append("Key", err)
	}
	if err := typesValidator.Var(o.OrgKey, "required"); err != nil {
		errors = errors.Append("OrgKey", err)
	}
	if err := typesValidator.Var(o.UserKey, "required"); err != nil {
		errors = errors.Append("UserKey", err)
	}
	if v, ok := any(o.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ProjectFixture struct {
	Key  string `json:"key" validate:"required"`
	Name string `json:"name" validate:"required"`

	// OrgKey References orgs.key.
	OrgKey      string  `json:"orgKey" validate:"required"`
	Description *string `json:"description,omitempty"`
}

func (p ProjectFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ProjectTokenFixture struct {
	Key string `json:"key" validate:"required"`

	// ProjectKey References projects.key.
	ProjectKey string  `json:"projectKey" validate:"required"`
	Token      string  `json:"token" validate:"required"`
	Name       *string `json:"name,omitempty"`
}

func (p ProjectTokenFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ProjectUserFixture struct {
	Key string `json:"key" validate:"required"`

	// ProjectKey References projects.key.
	ProjectKey string `json:"projectKey" validate:"required"`

	// OrgUserKey References orgUsers.key.
	OrgUserKey string                      `json:"orgUserKey" validate:"required"`
	PermLevel  ProjectUserFixturePermLevel `json:"permLevel" validate:"required"`
}

func (p ProjectUserFixture) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.Key, "required"); err != nil {
		errors = errors.Append("Key", err)
	}
	if err := typesValidator.Var(p.ProjectKey, "required"); err != nil {
		errors = errors.Append("ProjectKey", err)
	}
	if err := typesValidator.Var(p.OrgUserKey, "required"); err != nil {
		errors = errors.Append("OrgUserKey", err)
	}
	if v, ok := any(p.PermLevel).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PermLevel", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkFixture struct {
	ID  int64  `json:"id" validate:"required"`
	Key string `json:"key" validate:"required"`
}

func (l LinkFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(l))
}

type MonitorResponse struct {
	Monitor Monitor `json:"monitor"`
}

func (m MonitorResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.Monitor).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Monitor", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type BaseMonitorRequest struct {
	Name                  string `json:"name" validate:"required"`
	NotifyEveryoneByEmail *bool  `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int  `json:"teamIds,omitempty"`
	ChannelIds            []int  `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval `json:"repeatInterval,omitempty"`
}

func (b BaseMonitorRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(b.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if b.RepeatInterval != nil {
		if v, ok := any(b.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricMonitorRequest struct {
	Name                  string `json:"name" validate:"required"`
	NotifyEveryoneByEmail *bool  `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int  `json:"teamIds,omitempty"`
	ChannelIds            []int  `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval          `json:"repeatInterval,omitempty"`
	Type           MetricMonitorRequestType `json:"type" validate:"required"`
	Params         MetricMonitorParams      `json:"params"`
}

func (m MetricMonitorRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(m.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if m.RepeatInterval != nil {
		if v, ok := any(m.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if v, ok := any(m.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(m.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ErrorMonitorRequest struct {
	Name                  string `json:"name" validate:"required"`
	NotifyEveryoneByEmail *bool  `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int  `json:"teamIds,omitempty"`
	ChannelIds            []int  `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval         `json:"repeatInterval,omitempty"`
	Type           ErrorMonitorRequestType `json:"type" validate:"required"`
	Params         ErrorMonitorParams      `json:"params"`
}

func (e ErrorMonitorRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if e.RepeatInterval != nil {
		if v, ok := any(e.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if v, ok := any(e.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(e.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricMonitorParams struct {
	Metrics      []MonitorMetric                  `json:"metrics" validate:"required"`
	Query        string                           `json:"query" validate:"required"`
	ColumnName   *string                          `json:"columnName,omitempty"`
	ColumnUnit   *string                          `json:"columnUnit,omitempty"`
	BoundsSource *MetricMonitorParamsBoundsSource `json:"boundsSource,omitempty"`

	// Resolution Resolution in milliseconds.
	Resolution      *float32                      `json:"resolution,omitempty"`
	NumEvalPoints   *int                          `json:"numEvalPoints,omitempty"`
	MinAllowedValue *float32                      `json:"minAllowedValue,omitempty"`
	MaxAllowedValue *float32                      `json:"maxAllowedValue,omitempty"`
	Flapping        *FlappingParams               `json:"flapping,omitempty"`
	Tolerance       *MetricMonitorParamsTolerance `json:"tolerance,omitempty"`

	// TrainingPeriod Training period in milliseconds.
	TrainingPeriod *float32                      `json:"trainingPeriod,omitempty"`
	MinDevFraction *float32                      `json:"minDevFraction,omitempty"`
	MinDevValue    *float32                      `json:"minDevValue,omitempty"`
	NullsMode      *MetricMonitorParamsNullsMode `json:"nullsMode,omitempty"`

	// TimeOffset Time offset in milliseconds.
	TimeOffset *float32 `json:"timeOffset,omitempty"`
}

func (m MetricMonitorParams) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range m.Metrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Metrics[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(m.Query, "required"); err != nil {
		errors = errors.Append("Query", err)
	}
	if m.BoundsSource != nil {
		if v, ok := any(m.BoundsSource).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("BoundsSource", err)
			}
		}
	}
	if m.Flapping != nil {
		if v, ok := any(m.Flapping).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Flapping", err)
			}
		}
	}
	if m.Tolerance != nil {
		if v, ok := any(m.Tolerance).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Tolerance", err)
			}
		}
	}
	if m.NullsMode != nil {
		if v, ok := any(m.NullsMode).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NullsMode", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ErrorMonitorParams struct {
	Metrics []MonitorMetric `json:"metrics" validate:"required"`
	Query   string          `json:"query" validate:"required"`
}

func (e ErrorMonitorParams) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.Metrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Metrics[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(e.Query, "required"); err != nil {
		errors = errors.Append("Query", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type FlappingParams struct {
	MinAllowedValue *float32 `json:"minAllowedValue,omitempty"`
	MaxAllowedValue *float32 `json:"maxAllowedValue,omitempty"`
}

type MonitorMetric struct {
	Name  string  `json:"name" validate:"required"`
	Alias *string `json:"alias,omitempty"`
}

func (m MonitorMetric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

// RepeatInterval Monitor repeat interval configuration.
type RepeatInterval struct {
	RepeatInterval_OneOf *RepeatInterval_OneOf `json:"-"`
}

func (r RepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if r.RepeatInterval_OneOf != nil {
		if v, ok := any(r.RepeatInterval_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (r RepeatInterval) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(r.RepeatInterval_OneOf)
		if err != nil {
			return nil, fmt.Errorf("RepeatInterval_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (r *RepeatInterval) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if r.RepeatInterval_OneOf == nil {
		r.RepeatInterval_OneOf = &RepeatInterval_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, r.RepeatInterval_OneOf); err != nil {
		return fmt.Errorf("RepeatInterval_OneOf unmarshal: %w", err)
	}

	return nil
}

type DefaultRepeatInterval struct {
	Strategy *DefaultRepeatIntervalStrategy `json:"strategy,omitempty"`
}

func (d DefaultRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if d.Strategy != nil {
		if v, ok := any(d.Strategy).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Strategy", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type FixedRepeatInterval struct {
	Strategy FixedRepeatIntervalStrategy `json:"strategy" validate:"required"`

	// Interval Fixed interval in milliseconds.
	Interval float32 `json:"interval" validate:"required"`
}

func (f FixedRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(f.Strategy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Strategy", err)
		}
	}
	if err := typesValidator.Var(f.Interval, "required"); err != nil {
		errors = errors.Append("Interval", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinearRepeatInterval struct {
	Strategy LinearRepeatIntervalStrategy `json:"strategy" validate:"required"`

	// Min Minimum interval in milliseconds.
	Min float32 `json:"min" validate:"required"`

	// Max Maximum interval in milliseconds.
	Max float32 `json:"max" validate:"required"`
}

func (l LinearRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.Strategy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Strategy", err)
		}
	}
	if err := typesValidator.Var(l.Min, "required"); err != nil {
		errors = errors.Append("Min", err)
	}
	if err := typesValidator.Var(l.Max, "required"); err != nil {
		errors = errors.Append("Max", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExponentialRepeatInterval struct {
	Strategy ExponentialRepeatIntervalStrategy `json:"strategy" validate:"required"`

	// Min Minimum interval in milliseconds.
	Min float32 `json:"min" validate:"required"`

	// Max Maximum interval in milliseconds.
	Max float32 `json:"max" validate:"required"`
}

func (e ExponentialRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Strategy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Strategy", err)
		}
	}
	if err := typesValidator.Var(e.Min, "required"); err != nil {
		errors = errors.Append("Min", err)
	}
	if err := typesValidator.Var(e.Max, "required"); err != nil {
		errors = errors.Append("Max", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Monitor struct {
	ID                    int64         `json:"id" validate:"required"`
	Name                  string        `json:"name" validate:"required"`
	Type                  MonitorType   `json:"type" validate:"required"`
	Status                MonitorStatus `json:"status" validate:"required"`
	NotifyEveryoneByEmail *bool         `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int         `json:"teamIds,omitempty"`
	ChannelIds            []int         `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval `json:"repeatInterval,omitempty"`
	Params         map[string]any  `json:"params,omitempty"`
	CreatedAt      *float32        `json:"createdAt,omitempty"`
	UpdatedAt      *float32        `json:"updatedAt,omitempty"`
}

func (m Monitor) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(m.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(m.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(m.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(m.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if m.RepeatInterval != nil {
		if v, ok := any(m.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Dashboard struct {
	ID             int64                  `json:"id" validate:"required"`
	ProjectID      int64                  `json:"projectId" validate:"required"`
	TemplateID     *string                `json:"templateId,omitempty"`
	Name           string                 `json:"name" validate:"required"`
	Pinned         *bool                  `json:"pinned,omitempty"`
	MinInterval    *float32               `json:"minInterval,omitempty"`
	TimeOffset     *float32               `json:"timeOffset,omitempty"`
	GridQuery      *string                `json:"gridQuery,omitempty"`
	GridMaxWidth   *int                   `json:"gridMaxWidth,omitempty"`
	TableMetrics   []MetricAlias          `json:"tableMetrics,omitempty"`
	TableQuery     *string                `json:"tableQuery,omitempty"`
	TableGrouping  []string               `json:"tableGrouping,omitempty"`
	TableColumnMap map[string]TableColumn `json:"tableColumnMap,omitempty"`
	CreatedAt      *float32               `json:"createdAt,omitempty"`
	UpdatedAt      *float32               `json:"updatedAt,omitempty"`
}

func (d Dashboard) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(d.ProjectID, "required"); err != nil {
		errors = errors.Append("ProjectID", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	for i, item := range d.TableMetrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableMetrics[%d]", i), err)
			}
		}
	}
	for k, v := range d.TableColumnMap {
		if validator, ok := any(v).(runtime.Validator); ok {
			if err := validator.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableColumnMap[%s]", k), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DashboardResponse struct {
	Dashboard Dashboard `json:"dashboard"`
}

func (d DashboardResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Dashboard).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Dashboard", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DashboardTableUpdate struct {
	Name           *string                `json:"name,omitempty"`
	TableMetrics   []MetricAlias          `json:"tableMetrics,omitempty"`
	TableQuery     *string                `json:"tableQuery,omitempty"`
	TableColumnMap map[string]TableColumn `json:"tableColumnMap,omitempty"`
}

func (d DashboardTableUpdate) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.TableMetrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableMetrics[%d]", i), err)
			}
		}
	}
	for k, v := range d.TableColumnMap {
		if validator, ok := any(v).(runtime.Validator); ok {
			if err := validator.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableColumnMap[%s]", k), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricAlias struct {
	Name  string `json:"name" validate:"required"`
	Alias string `json:"alias" validate:"required"`
}

func (m MetricAlias) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type TableColumn struct {
	Unit              *string             `json:"unit,omitempty"`
	Color             *string             `json:"color,omitempty"`
	AggFunc           *TableColumnAggFunc `json:"aggFunc,omitempty"`
	SparklineDisabled *bool               `json:"sparklineDisabled,omitempty"`
}

func (t TableColumn) Validate() error {
	var errors runtime.ValidationErrors
	if t.AggFunc != nil {
		if v, ok := any(t.AggFunc).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AggFunc", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridRow struct {
	ID          int64      `json:"id" validate:"required"`
	DashID      int64      `json:"dashId" validate:"required"`
	Title       string     `json:"title" validate:"required"`
	Description *string    `json:"description,omitempty"`
	Expanded    *bool      `json:"expanded,omitempty"`
	Index       int        `json:"index" validate:"required"`
	Items       []GridItem `json:"items,omitempty"`
	CreatedAt   *float32   `json:"createdAt,omitempty"`
	UpdatedAt   *float32   `json:"updatedAt,omitempty"`
}

func (g GridRow) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.DashID, "required"); err != nil {
		errors = errors.Append("DashID", err)
	}
	if err := typesValidator.Var(g.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Index, "required"); err != nil {
		errors = errors.Append("Index", err)
	}
	for i, item := range g.Items {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Items[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridRowRequest struct {
	Title       string  `json:"title" validate:"required"`
	Description *string `json:"description,omitempty"`
	Expanded    *bool   `json:"expanded,omitempty"`
}

func (g GridRowRequest) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GridRowResponse struct {
	GridRow GridRow `json:"gridRow"`
}

func (g GridRowResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.GridRow).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GridRow", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridItem struct {
	ID          int64            `json:"id" validate:"required"`
	Title       string           `json:"title" validate:"required"`
	Description *string          `json:"description,omitempty"`
	DashID      int64            `json:"dashId" validate:"required"`
	DashKind    GridItemDashKind `json:"dashKind" validate:"required"`
	RowID       *int64           `json:"rowId,omitempty"`
	Width       *int             `json:"width,omitempty"`
	Height      *int             `json:"height,omitempty"`
	XAxis       *int             `json:"xAxis,omitempty"`
	YAxis       *int             `json:"yAxis,omitempty"`
	Type        GridItemType     `json:"type" validate:"required"`
	Params      map[string]any   `json:"params,omitempty"`
	CreatedAt   *float32         `json:"createdAt,omitempty"`
	UpdatedAt   *float32         `json:"updatedAt,omitempty"`
}

func (g GridItem) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.DashID, "required"); err != nil {
		errors = errors.Append("DashID", err)
	}
	if v, ok := any(g.DashKind).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DashKind", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridItemRequest struct {
	Title       string                  `json:"title" validate:"required"`
	Description *string                 `json:"description,omitempty"`
	DashKind    GridItemRequestDashKind `json:"dashKind" validate:"required"`
	RowID       int64                   `json:"rowId" validate:"required"`
	Width       *int                    `json:"width,omitempty"`
	Height      *int                    `json:"height,omitempty"`
	XAxis       *int                    `json:"xAxis,omitempty"`
	YAxis       *int                    `json:"yAxis,omitempty"`
	Type        GridItemRequestType     `json:"type" validate:"required"`
	Params      map[string]any          `json:"params,omitempty"`
}

func (g GridItemRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if v, ok := any(g.DashKind).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DashKind", err)
		}
	}
	if err := typesValidator.Var(g.RowID, "required"); err != nil {
		errors = errors.Append("RowID", err)
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridItemResponse struct {
	GridItem GridItem `json:"gridItem"`
}

func (g GridItemResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.GridItem).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GridItem", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// SlackParams Slack params. When authMethod=webhook, webhookUrl is required. When authMethod=token, token and channel are required.
type SlackParams struct {
	WebhookURL *string                `json:"webhookUrl,omitempty"`
	Token      *string                `json:"token,omitempty"`
	Channel    *string                `json:"channel,omitempty"`
	AuthMethod *SlackParamsAuthMethod `json:"authMethod,omitempty"`
}

func (s SlackParams) Validate() error {
	var errors runtime.ValidationErrors
	if s.AuthMethod != nil {
		if v, ok := any(s.AuthMethod).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AuthMethod", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GoogleChatParams struct {
	WebhookURL string `json:"webhookUrl" validate:"required"`
}

func (g GoogleChatParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type MattermostParams struct {
	WebhookURL string `json:"webhookUrl" validate:"required"`
}

func (m MattermostParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type PagerdutyParams struct {
	RoutingKey string                  `json:"routingKey" validate:"required"`
	Severity   PagerdutyParamsSeverity `json:"severity" validate:"required"`
}

func (p PagerdutyParams) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.RoutingKey, "required"); err != nil {
		errors = errors.Append("RoutingKey", err)
	}
	if v, ok := any(p.Severity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Severity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ServicenowParams struct {
	URL         string                    `json:"url" validate:"required"`
	Username    string                    `json:"username" validate:"required"`
	Password    string                    `json:"password" validate:"required"`
	Category    *string                   `json:"category,omitempty"`
	Subcategory *string                   `json:"subcategory,omitempty"`
	Impact      *ServicenowParamsImpact   `json:"impact,omitempty"`
	Urgency     *ServicenowParamsUrgency  `json:"urgency,omitempty"`
	Severity    *ServicenowParamsSeverity `json:"severity,omitempty"`
	CallerID    *string                   `json:"callerId,omitempty"`
	Group       *string                   `json:"group,omitempty"`
	AssignedTo  *string                   `json:"assignedTo,omitempty"`
	OpenedBy    *string                   `json:"openedBy,omitempty"`
	Notify      *ServicenowParamsNotify   `json:"notify,omitempty"`
	DueDate     *string                   `json:"dueDate,omitempty"`
}

func (s ServicenowParams) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.URL, "required"); err != nil {
		errors = errors.Append("URL", err)
	}
	if err := typesValidator.Var(s.Username, "required"); err != nil {
		errors = errors.Append("Username", err)
	}
	if err := typesValidator.Var(s.Password, "required"); err != nil {
		errors = errors.Append("Password", err)
	}
	if s.Impact != nil {
		if v, ok := any(s.Impact).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Impact", err)
			}
		}
	}
	if s.Urgency != nil {
		if v, ok := any(s.Urgency).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Urgency", err)
			}
		}
	}
	if s.Severity != nil {
		if v, ok := any(s.Severity).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Severity", err)
			}
		}
	}
	if s.Notify != nil {
		if v, ok := any(s.Notify).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Notify", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OpsgenieParams struct {
	APIKey   string                 `json:"apiKey" validate:"required"`
	Priority OpsgenieParamsPriority `json:"priority" validate:"required"`
}

func (o OpsgenieParams) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.APIKey, "required"); err != nil {
		errors = errors.Append("APIKey", err)
	}
	if v, ok := any(o.Priority).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Priority", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TelegramParams struct {
	ChatID int64 `json:"chatId" validate:"required"`
}

func (t TelegramParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TeamsParams struct {
	WebhookURL string `json:"webhookUrl" validate:"required"`
}

func (t TeamsParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type WebhookParams struct {
	URL     string         `json:"url" validate:"required"`
	Payload map[string]any `json:"payload,omitempty"`
}

func (w WebhookParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(w))
}

type NotificationChannel struct {
	ID           int64                           `json:"id" validate:"required"`
	ProjectID    int64                           `json:"projectId" validate:"required"`
	Name         string                          `json:"name" validate:"required"`
	Type         NotificationChannelType         `json:"type" validate:"required"`
	Status       NotificationChannelStatus       `json:"status" validate:"required"`
	ErrorData    *string                         `json:"error,omitempty"`
	MatchAll     *bool                           `json:"matchAll,omitempty"`
	Condition    *string                         `json:"condition,omitempty"`
	Priorities   []NotificationChannelPriorities `json:"priorities,omitempty"`
	Params       NotificationChannel_Params      `json:"params"`
	MonitorIds   []int64                         `json:"monitorIds,omitempty"`
	MonitorCount *int                            `json:"monitorCount,omitempty"`
	SentCount    *int                            `json:"sentCount,omitempty"`
	LastSentAt   *time.Time                      `json:"lastSentAt,omitempty"`
}

func (n NotificationChannel) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(n.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(n.ProjectID, "required"); err != nil {
		errors = errors.Append("ProjectID", err)
	}
	if err := typesValidator.Var(n.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(n.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(n.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range n.Priorities {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Priorities[%d]", i), err)
			}
		}
	}
	if v, ok := any(n.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NotificationChannel_Params struct {
	NotificationChannel_Params_OneOf *NotificationChannel_Params_OneOf `json:"-"`
}

func (n NotificationChannel_Params) Validate() error {
	var errors runtime.ValidationErrors
	if n.NotificationChannel_Params_OneOf != nil {
		if v, ok := any(n.NotificationChannel_Params_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NotificationChannel_Params_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NotificationChannel_Params) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NotificationChannel_Params_OneOf)
		if err != nil {
			return nil, fmt.Errorf("NotificationChannel_Params_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NotificationChannel_Params) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NotificationChannel_Params_OneOf == nil {
		n.NotificationChannel_Params_OneOf = &NotificationChannel_Params_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NotificationChannel_Params_OneOf); err != nil {
		return fmt.Errorf("NotificationChannel_Params_OneOf unmarshal: %w", err)
	}

	return nil
}

type NotificationChannelRequest struct {
	Name       string                                 `json:"name" validate:"required"`
	Type       NotificationChannelRequestType         `json:"type" validate:"required"`
	MatchAll   *bool                                  `json:"matchAll,omitempty"`
	MonitorIds []int64                                `json:"monitorIds,omitempty"`
	Condition  *string                                `json:"condition,omitempty"`
	Priorities []NotificationChannelRequestPriorities `json:"priorities" validate:"required"`
	Params     NotificationChannelRequest_Params      `json:"params"`
}

func (n NotificationChannelRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(n.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(n.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	for i, item := range n.Priorities {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Priorities[%d]", i), err)
			}
		}
	}
	if v, ok := any(n.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NotificationChannelRequest_Params struct {
	NotificationChannelRequest_Params_OneOf *NotificationChannelRequest_Params_OneOf `json:"-"`
}

func (n NotificationChannelRequest_Params) Validate() error {
	var errors runtime.ValidationErrors
	if n.NotificationChannelRequest_Params_OneOf != nil {
		if v, ok := any(n.NotificationChannelRequest_Params_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NotificationChannelRequest_Params_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NotificationChannelRequest_Params) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NotificationChannelRequest_Params_OneOf)
		if err != nil {
			return nil, fmt.Errorf("NotificationChannelRequest_Params_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NotificationChannelRequest_Params) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NotificationChannelRequest_Params_OneOf == nil {
		n.NotificationChannelRequest_Params_OneOf = &NotificationChannelRequest_Params_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NotificationChannelRequest_Params_OneOf); err != nil {
		return fmt.Errorf("NotificationChannelRequest_Params_OneOf unmarshal: %w", err)
	}

	return nil
}

type NotificationChannelResponse struct {
	Channel NotificationChannel `json:"channel"`
}

func (n NotificationChannelResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.Channel).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Channel", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}
