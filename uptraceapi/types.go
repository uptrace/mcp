// Code generated by oapi-codegen. DO NOT EDIT.

package uptraceapi

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/uptrace/oapi-codegen-dd/v3/pkg/runtime"
)

type OrderItem struct {
	Key   *string         `json:"key,omitempty"`
	Order *OrderItemOrder `json:"order,omitempty"`
}

func (o OrderItem) Validate() error {
	var errors runtime.ValidationErrors
	if o.Order != nil {
		if v, ok := any(o.Order).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Order", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// Span A span representing an individual operation in a distributed trace.
type Span struct {
	// ID Span ID (hex-encoded).
	ID string `json:"id" jsonschema:"Span ID (hex-encoded)." validate:"required"`

	// ParentID Parent span ID (hex-encoded, empty for root spans).
	ParentID *string `json:"parentId,omitempty" jsonschema:"Parent span ID (hex-encoded, empty for root spans)."`

	// TraceID Trace ID (hex-encoded).
	TraceID string `json:"traceId" jsonschema:"Trace ID (hex-encoded)." validate:"required"`

	// Standalone Whether the span is standalone (not part of a trace).
	Standalone *bool `json:"standalone,omitempty" jsonschema:"Whether the span is standalone (not part of a trace)."`

	// ProjectID Project ID.
	ProjectID *uint32 `json:"projectId,omitempty" jsonschema:"Project ID."`

	// GroupID Group ID (uint64 as string).
	GroupID *string `json:"groupId,omitempty" jsonschema:"Group ID (uint64 as string)."`

	// Type Telemetry type (spans, events, logs, funcs).
	Type *string `json:"type,omitempty" jsonschema:"Telemetry type (spans, events, logs, funcs)."`

	// System Detected system (e.g., httpserver:all, db:postgresql, log:error).
	System *string `json:"system,omitempty" jsonschema:"Detected system (e.g., httpserver:all, db:postgresql, log:error)."`

	// Kind Span kind (client, server, producer, consumer, internal).
	Kind *string `json:"kind,omitempty" jsonschema:"Span kind (client, server, producer, consumer, internal)."`

	// Name Span name.
	Name string `json:"name" jsonschema:"Span name." validate:"required"`

	// EventName Event name (for event spans).
	EventName *string `json:"eventName,omitempty" jsonschema:"Event name (for event spans)."`

	// DisplayName Human-readable operation summary.
	DisplayName *string `json:"displayName,omitempty" jsonschema:"Human-readable operation summary."`

	// Time Span start time as unix milliseconds.
	Time float64 `json:"time" jsonschema:"Span start time as unix milliseconds." validate:"required"`

	// Duration Duration in milliseconds.
	Duration float64 `json:"duration" jsonschema:"Duration in milliseconds." validate:"required"`

	// StatusCode Status code (ok, error, unset).
	StatusCode string `json:"statusCode" jsonschema:"Status code (ok, error, unset)." validate:"required"`

	// StatusMessage Optional status message.
	StatusMessage *string `json:"statusMessage,omitempty" jsonschema:"Optional status message."`

	// Attrs Span attributes as key-value map. Keys include type suffix (e.g., service_name::str, count::int).
	Attrs map[string]any `json:"attrs,omitempty" jsonschema:"Span attributes as key-value map. Keys include type suffix (e.g., service_name::str, count::int)."`

	// Events Child event spans.
	Events []map[string]any `json:"events,omitempty" jsonschema:"Child event spans."`

	// Logs Child log spans.
	Logs []map[string]any `json:"logs,omitempty" jsonschema:"Child log spans."`

	// Links Span links to other spans.
	Links *Span_Links `json:"links,omitempty" jsonschema:"Span links to other spans."`
}

func (s Span) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(s.TraceID, "required"); err != nil {
		errors = errors.Append("TraceID", err)
	}
	if err := typesValidator.Var(s.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(s.Time, "required"); err != nil {
		errors = errors.Append("Time", err)
	}
	if err := typesValidator.Var(s.Duration, "required"); err != nil {
		errors = errors.Append("Duration", err)
	}
	if err := typesValidator.Var(s.StatusCode, "required"); err != nil {
		errors = errors.Append("StatusCode", err)
	}
	if s.Links != nil {
		if v, ok := any(s.Links).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Links", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// Span_Links Span links to other spans.
type Span_Links []Span_Links_Item

type Span_Links_Item struct {
	TraceID *string        `json:"traceId,omitempty"`
	SpanID  *string        `json:"spanId,omitempty"`
	Attrs   map[string]any `json:"attrs,omitempty"`
}

// GroupsResult Result of a span group aggregation query.
type GroupsResult struct {
	// Groups Array of group rows with dynamic columns. Each row may contain __hash, __name, __query metadata fields.
	Groups []map[string]any `json:"groups" jsonschema:"Array of group rows with dynamic columns. Each row may contain __hash, __name, __query metadata fields." validate:"required"`

	// Columns Column definitions describing the result schema.
	Columns []QueryColumn `json:"columns,omitempty" jsonschema:"Column definitions describing the result schema."`

	// HasMore Whether more results exist beyond the limit.
	HasMore *bool `json:"hasMore,omitempty" jsonschema:"Whether more results exist beyond the limit."`

	// Query Parsed query parts with error state.
	Query []map[string]any `json:"query,omitempty" jsonschema:"Parsed query parts with error state."`

	// Order Applied sorting configuration.
	Order []OrderItem `json:"order,omitempty" jsonschema:"Applied sorting configuration."`

	// Search Applied search matchers.
	Search []map[string]any `json:"search,omitempty" jsonschema:"Applied search matchers."`

	// WhereAttrs Map of WHERE attribute names to their matched values.
	WhereAttrs map[string]any `json:"whereAttrs,omitempty" jsonschema:"Map of WHERE attribute names to their matched values."`
}

func (g GroupsResult) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Groups, "required"); err != nil {
		errors = errors.Append("Groups", err)
	}
	for i, item := range g.Columns {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Columns[%d]", i), err)
			}
		}
	}
	for i, item := range g.Order {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Order[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// QueryColumn Column definition for a query result.
type QueryColumn struct {
	// Name Column name.
	Name string `json:"name" jsonschema:"Column name." validate:"required"`

	// Expr Column expression as written in the query.
	Expr *string `json:"expr,omitempty" jsonschema:"Column expression as written in the query."`

	// Unit Column unit (e.g., ms, bytes).
	Unit *string `json:"unit,omitempty" jsonschema:"Column unit (e.g., ms, bytes)."`

	// IsNum Whether the column contains numeric values.
	IsNum *bool `json:"isNum,omitempty" jsonschema:"Whether the column contains numeric values."`

	// IsAgg Whether the column is an aggregation.
	IsAgg *bool `json:"isAgg,omitempty" jsonschema:"Whether the column is an aggregation."`

	// IsGroup Whether the column is a GROUP BY key.
	IsGroup *bool `json:"isGroup,omitempty" jsonschema:"Whether the column is a GROUP BY key."`

	// AggFunc Aggregation function applied to this column.
	AggFunc *string `json:"aggFunc,omitempty" jsonschema:"Aggregation function applied to this column."`
}

func (q QueryColumn) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(q))
}

// Timeseries A named timeseries with values aligned to timestamps.
type Timeseries struct {
	// Name Metric name (e.g., countPerMin, errorCountPerMin, durationP50, durationP90, durationP99).
	Name string `json:"name" jsonschema:"Metric name (e.g., countPerMin, errorCountPerMin, durationP50, durationP90, durationP99)." validate:"required"`

	// Value Array of metric values.
	Value []float64 `json:"value" jsonschema:"Array of metric values." validate:"required"`

	// Time Array of timestamps as unix milliseconds.
	Time []float64 `json:"time" jsonschema:"Array of timestamps as unix milliseconds." validate:"required"`
}

func (t Timeseries) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type AnnotationCreateRequest struct {
	// Name Annotation name.
	Name string `json:"name" jsonschema:"Annotation name." validate:"required"`

	// Description Annotation description text in Markdown format.
	Description *string `json:"description,omitempty" jsonschema:"Annotation description text in Markdown format."`

	// Color Color to be used in charts.
	Color *string `json:"color,omitempty" jsonschema:"Color to be used in charts."`

	// Attrs Key-value metadata.
	Attrs map[string]string `json:"attrs,omitempty" jsonschema:"Key-value metadata."`

	// Fingerprint Unique string used for deduplication.
	Fingerprint *string `json:"fingerprint,omitempty" jsonschema:"Unique string used for deduplication."`

	// Time Overrides annotation time in RFC3339 format.
	Time *time.Time `json:"time,omitempty" jsonschema:"Overrides annotation time in RFC3339 format."`
}

func (a AnnotationCreateRequest) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type ListDashboardTemplatesResponse struct {
	Templates []DashboardTemplateItem `json:"templates" validate:"required"`
}

func (l ListDashboardTemplatesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.Templates {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Templates[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DashboardTemplateItem struct {
	// ID Template ID.
	ID string `json:"id" jsonschema:"Template ID." validate:"required"`

	// Name Template name.
	Name string `json:"name" jsonschema:"Template name." validate:"required"`

	// Description Template description.
	Description string `json:"description" jsonschema:"Template description." validate:"required"`
}

func (d DashboardTemplateItem) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetDashboardTemplateResponse struct {
	Template DashboardTemplate `json:"template"`
}

func (g GetDashboardTemplateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Template).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Template", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DashboardTemplate struct {
	// ID Template ID.
	ID string `json:"id" jsonschema:"Template ID." validate:"required"`

	// Name Template name.
	Name string `json:"name" jsonschema:"Template name." validate:"required"`

	// Description Template description.
	Description string `json:"description" jsonschema:"Template description." validate:"required"`

	// Tags Template tags.
	Tags []string `json:"tags,omitempty" jsonschema:"Template tags."`
}

func (d DashboardTemplate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type ExploreMetricsResponse struct {
	Metrics []ExploredMetric `json:"metrics" validate:"required"`
	HasMore bool             `json:"hasMore"`
}

func (e ExploreMetricsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.Metrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Metrics[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExploredMetric struct {
	// Name Metric name.
	Name string `json:"name" jsonschema:"Metric name." validate:"required"`

	// Instrument OpenTelemetry instrument type.
	Instrument ExploredMetricInstrument `json:"instrument" jsonschema:"OpenTelemetry instrument type." validate:"required"`

	// Unit Metric unit.
	Unit *string `json:"unit,omitempty" jsonschema:"Metric unit."`

	// Description Metric description.
	Description *string `json:"description,omitempty" jsonschema:"Metric description."`

	// AttrKeys Available attribute keys for grouping.
	AttrKeys []string `json:"attrKeys,omitempty" jsonschema:"Available attribute keys for grouping."`

	// LibraryName Instrumentation library name.
	LibraryName *string `json:"libraryName,omitempty" jsonschema:"Instrumentation library name."`

	// LibraryVersion Instrumentation library version.
	LibraryVersion *string `json:"libraryVersion,omitempty" jsonschema:"Instrumentation library version."`

	// NumTimeseries Number of active timeseries.
	NumTimeseries *int `json:"numTimeseries,omitempty" jsonschema:"Number of active timeseries."`
}

func (e ExploredMetric) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(e.Instrument).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Instrument", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ListMetricAttributesResponse struct {
	Items []MetricAttributeKey `json:"items" validate:"required"`
}

func (l ListMetricAttributesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.Items {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Items[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricAttributeKey struct {
	// Value Attribute key with type suffix (e.g. host_name::str).
	Value string `json:"value" jsonschema:"Attribute key with type suffix (e.g. host_name::str)." validate:"required"`

	// Kind Attribute type: str, int, float.
	Kind string `json:"kind" jsonschema:"Attribute type: str, int, float." validate:"required"`

	// Unit Attribute unit.
	Unit *string `json:"unit,omitempty" jsonschema:"Attribute unit."`

	// Pinned Whether the attribute is pinned.
	Pinned *bool `json:"pinned,omitempty" jsonschema:"Whether the attribute is pinned."`

	// Count Number of metrics using this attribute.
	Count int `json:"count" jsonschema:"Number of metrics using this attribute." validate:"required"`
}

func (m MetricAttributeKey) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type ListMetricAttributeValuesResponse struct {
	Items   []MetricAttributeValue `json:"items" validate:"required"`
	HasMore bool                   `json:"hasMore"`
}

func (l ListMetricAttributeValuesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.Items {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Items[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricAttributeValue struct {
	// Value Attribute value.
	Value string `json:"value" jsonschema:"Attribute value." validate:"required"`

	// Count Occurrence count.
	Count int `json:"count" jsonschema:"Occurrence count." validate:"required"`
}

func (m MetricAttributeValue) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type Error struct {
	Code    string `json:"code" validate:"required"`
	Message string `json:"message" validate:"required"`
}

func (e Error) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

func (s Error) Error() string {
	return "unmapped client error"
}

// SeedDataRequest Fixture data used to create, update, or delete resources by key.
type SeedDataRequest struct {
	Users         []UserFixture         `json:"users,omitempty"`
	UserTokens    []UserTokenFixture    `json:"userTokens,omitempty"`
	Orgs          []OrgFixture          `json:"orgs,omitempty"`
	OrgUsers      []OrgUserFixture      `json:"orgUsers,omitempty"`
	Projects      []ProjectFixture      `json:"projects,omitempty"`
	ProjectTokens []ProjectTokenFixture `json:"projectTokens,omitempty"`
	ProjectUsers  []ProjectUserFixture  `json:"projectUsers,omitempty"`
}

func (s SeedDataRequest) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range s.Users {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Users[%d]", i), err)
			}
		}
	}
	for i, item := range s.UserTokens {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("UserTokens[%d]", i), err)
			}
		}
	}
	for i, item := range s.Orgs {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Orgs[%d]", i), err)
			}
		}
	}
	for i, item := range s.OrgUsers {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OrgUsers[%d]", i), err)
			}
		}
	}
	for i, item := range s.Projects {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Projects[%d]", i), err)
			}
		}
	}
	for i, item := range s.ProjectTokens {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("ProjectTokens[%d]", i), err)
			}
		}
	}
	for i, item := range s.ProjectUsers {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("ProjectUsers[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// LinkDataRequest Links existing resources to fixture keys.
type LinkDataRequest struct {
	Orgs          []LinkFixture `json:"orgs,omitempty"`
	OrgUsers      []LinkFixture `json:"orgUsers,omitempty"`
	Projects      []LinkFixture `json:"projects,omitempty"`
	ProjectTokens []LinkFixture `json:"projectTokens,omitempty"`
}

func (l LinkDataRequest) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.Orgs {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Orgs[%d]", i), err)
			}
		}
	}
	for i, item := range l.OrgUsers {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OrgUsers[%d]", i), err)
			}
		}
	}
	for i, item := range l.Projects {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Projects[%d]", i), err)
			}
		}
	}
	for i, item := range l.ProjectTokens {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("ProjectTokens[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserFixture struct {
	// Key Unique fixture key.
	Key string `json:"key" jsonschema:"Unique fixture key." validate:"required"`

	// Name Display name.
	Name  string        `json:"name" jsonschema:"Display name." validate:"required"`
	Email runtime.Email `json:"email" validate:"required"`

	// Password Plain-text password (hashed by Uptrace).
	Password string `json:"password" jsonschema:"Plain-text password (hashed by Uptrace)." validate:"required"`
}

func (u UserFixture) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(u.Key, "required"); err != nil {
		errors = errors.Append("Key", err)
	}
	if err := typesValidator.Var(u.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.Password, "required"); err != nil {
		errors = errors.Append("Password", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserTokenFixture struct {
	Key string `json:"key" validate:"required"`

	// UserKey References users.key.
	UserKey string `json:"userKey" jsonschema:"References users.key." validate:"required"`
	Token   string `json:"token" validate:"required"`

	// Name Human-readable token name.
	Name *string `json:"name,omitempty" jsonschema:"Human-readable token name."`
}

func (u UserTokenFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type OrgFixture struct {
	Key         string  `json:"key" validate:"required"`
	Name        string  `json:"name" validate:"required"`
	Description *string `json:"description,omitempty"`
}

func (o OrgFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(o))
}

type OrgUserFixture struct {
	Key string `json:"key" validate:"required"`

	// OrgKey References orgs.key.
	OrgKey string `json:"orgKey" jsonschema:"References orgs.key." validate:"required"`

	// UserKey References users.key.
	UserKey string             `json:"userKey" jsonschema:"References users.key." validate:"required"`
	Role    OrgUserFixtureRole `json:"role" validate:"required"`
}

func (o OrgUserFixture) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Key, "required"); err != nil {
		errors = errors.Append("Key", err)
	}
	if err := typesValidator.Var(o.OrgKey, "required"); err != nil {
		errors = errors.Append("OrgKey", err)
	}
	if err := typesValidator.Var(o.UserKey, "required"); err != nil {
		errors = errors.Append("UserKey", err)
	}
	if v, ok := any(o.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ProjectFixture struct {
	Key  string `json:"key" validate:"required"`
	Name string `json:"name" validate:"required"`

	// OrgKey References orgs.key.
	OrgKey      string  `json:"orgKey" jsonschema:"References orgs.key." validate:"required"`
	Description *string `json:"description,omitempty"`
}

func (p ProjectFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ProjectTokenFixture struct {
	Key string `json:"key" validate:"required"`

	// ProjectKey References projects.key.
	ProjectKey string  `json:"projectKey" jsonschema:"References projects.key." validate:"required"`
	Token      string  `json:"token" validate:"required"`
	Name       *string `json:"name,omitempty"`
}

func (p ProjectTokenFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ProjectUserFixture struct {
	Key string `json:"key" validate:"required"`

	// ProjectKey References projects.key.
	ProjectKey string `json:"projectKey" jsonschema:"References projects.key." validate:"required"`

	// OrgUserKey References orgUsers.key.
	OrgUserKey string                      `json:"orgUserKey" jsonschema:"References orgUsers.key." validate:"required"`
	PermLevel  ProjectUserFixturePermLevel `json:"permLevel" validate:"required"`
}

func (p ProjectUserFixture) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.Key, "required"); err != nil {
		errors = errors.Append("Key", err)
	}
	if err := typesValidator.Var(p.ProjectKey, "required"); err != nil {
		errors = errors.Append("ProjectKey", err)
	}
	if err := typesValidator.Var(p.OrgUserKey, "required"); err != nil {
		errors = errors.Append("OrgUserKey", err)
	}
	if v, ok := any(p.PermLevel).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PermLevel", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkFixture struct {
	ID  int64  `json:"id" validate:"required"`
	Key string `json:"key" validate:"required"`
}

func (l LinkFixture) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(l))
}

type MonitorResponse struct {
	Monitor Monitor `json:"monitor"`
}

func (m MonitorResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.Monitor).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Monitor", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type BaseMonitorRequest struct {
	Name                  string `json:"name" validate:"required"`
	NotifyEveryoneByEmail *bool  `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int  `json:"teamIds,omitempty"`
	ChannelIds            []int  `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval `json:"repeatInterval,omitempty" jsonschema:"Monitor repeat interval configuration."`
}

func (b BaseMonitorRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(b.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if b.RepeatInterval != nil {
		if v, ok := any(b.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricMonitorRequest struct {
	Name                  string `json:"name" validate:"required"`
	NotifyEveryoneByEmail *bool  `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int  `json:"teamIds,omitempty"`
	ChannelIds            []int  `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval          `json:"repeatInterval,omitempty" jsonschema:"Monitor repeat interval configuration."`
	Type           MetricMonitorRequestType `json:"type" validate:"required"`
	Params         MetricMonitorParams      `json:"params"`
}

func (m MetricMonitorRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(m.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if m.RepeatInterval != nil {
		if v, ok := any(m.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if v, ok := any(m.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(m.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ErrorMonitorRequest struct {
	Name                  string `json:"name" validate:"required"`
	NotifyEveryoneByEmail *bool  `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int  `json:"teamIds,omitempty"`
	ChannelIds            []int  `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval         `json:"repeatInterval,omitempty" jsonschema:"Monitor repeat interval configuration."`
	Type           ErrorMonitorRequestType `json:"type" validate:"required"`
	Params         ErrorMonitorParams      `json:"params"`
}

func (e ErrorMonitorRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if e.RepeatInterval != nil {
		if v, ok := any(e.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if v, ok := any(e.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(e.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricMonitorParams struct {
	Metrics      []MonitorMetric                  `json:"metrics" validate:"required"`
	Query        string                           `json:"query" validate:"required"`
	ColumnName   *string                          `json:"columnName,omitempty"`
	ColumnUnit   *string                          `json:"columnUnit,omitempty"`
	BoundsSource *MetricMonitorParamsBoundsSource `json:"boundsSource,omitempty"`

	// Resolution Resolution in milliseconds.
	Resolution      *float32                      `json:"resolution,omitempty" jsonschema:"Resolution in milliseconds."`
	NumEvalPoints   *int                          `json:"numEvalPoints,omitempty"`
	MinAllowedValue *float32                      `json:"minAllowedValue,omitempty"`
	MaxAllowedValue *float32                      `json:"maxAllowedValue,omitempty"`
	Flapping        *FlappingParams               `json:"flapping,omitempty"`
	Tolerance       *MetricMonitorParamsTolerance `json:"tolerance,omitempty"`

	// TrainingPeriod Training period in milliseconds.
	TrainingPeriod *float32                      `json:"trainingPeriod,omitempty" jsonschema:"Training period in milliseconds."`
	MinDevFraction *float32                      `json:"minDevFraction,omitempty"`
	MinDevValue    *float32                      `json:"minDevValue,omitempty"`
	NullsMode      *MetricMonitorParamsNullsMode `json:"nullsMode,omitempty"`

	// TimeOffset Time offset in milliseconds.
	TimeOffset *float32 `json:"timeOffset,omitempty" jsonschema:"Time offset in milliseconds."`
}

func (m MetricMonitorParams) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range m.Metrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Metrics[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(m.Query, "required"); err != nil {
		errors = errors.Append("Query", err)
	}
	if m.BoundsSource != nil {
		if v, ok := any(m.BoundsSource).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("BoundsSource", err)
			}
		}
	}
	if m.Flapping != nil {
		if v, ok := any(m.Flapping).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Flapping", err)
			}
		}
	}
	if m.Tolerance != nil {
		if v, ok := any(m.Tolerance).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Tolerance", err)
			}
		}
	}
	if m.NullsMode != nil {
		if v, ok := any(m.NullsMode).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NullsMode", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ErrorMonitorParams struct {
	Metrics []MonitorMetric `json:"metrics" validate:"required"`
	Query   string          `json:"query" validate:"required"`
}

func (e ErrorMonitorParams) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.Metrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Metrics[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(e.Query, "required"); err != nil {
		errors = errors.Append("Query", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type FlappingParams struct {
	MinAllowedValue *float32 `json:"minAllowedValue,omitempty"`
	MaxAllowedValue *float32 `json:"maxAllowedValue,omitempty"`
}

type MonitorMetric struct {
	Name  string  `json:"name" validate:"required"`
	Alias *string `json:"alias,omitempty"`
}

func (m MonitorMetric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

// RepeatInterval Monitor repeat interval configuration.
type RepeatInterval struct {
	RepeatInterval_OneOf *RepeatInterval_OneOf `json:"-"`
}

func (r RepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if r.RepeatInterval_OneOf != nil {
		if v, ok := any(r.RepeatInterval_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (r RepeatInterval) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(r.RepeatInterval_OneOf)
		if err != nil {
			return nil, fmt.Errorf("RepeatInterval_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (r *RepeatInterval) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if r.RepeatInterval_OneOf == nil {
		r.RepeatInterval_OneOf = &RepeatInterval_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, r.RepeatInterval_OneOf); err != nil {
		return fmt.Errorf("RepeatInterval_OneOf unmarshal: %w", err)
	}

	return nil
}

type DefaultRepeatInterval struct {
	Strategy *DefaultRepeatIntervalStrategy `json:"strategy,omitempty"`
}

func (d DefaultRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if d.Strategy != nil {
		if v, ok := any(d.Strategy).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Strategy", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type FixedRepeatInterval struct {
	Strategy FixedRepeatIntervalStrategy `json:"strategy" validate:"required"`

	// Interval Fixed interval in milliseconds.
	Interval float32 `json:"interval" jsonschema:"Fixed interval in milliseconds." validate:"required"`
}

func (f FixedRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(f.Strategy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Strategy", err)
		}
	}
	if err := typesValidator.Var(f.Interval, "required"); err != nil {
		errors = errors.Append("Interval", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinearRepeatInterval struct {
	Strategy LinearRepeatIntervalStrategy `json:"strategy" validate:"required"`

	// Min Minimum interval in milliseconds.
	Min float32 `json:"min" jsonschema:"Minimum interval in milliseconds." validate:"required"`

	// Max Maximum interval in milliseconds.
	Max float32 `json:"max" jsonschema:"Maximum interval in milliseconds." validate:"required"`
}

func (l LinearRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.Strategy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Strategy", err)
		}
	}
	if err := typesValidator.Var(l.Min, "required"); err != nil {
		errors = errors.Append("Min", err)
	}
	if err := typesValidator.Var(l.Max, "required"); err != nil {
		errors = errors.Append("Max", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExponentialRepeatInterval struct {
	Strategy ExponentialRepeatIntervalStrategy `json:"strategy" validate:"required"`

	// Min Minimum interval in milliseconds.
	Min float32 `json:"min" jsonschema:"Minimum interval in milliseconds." validate:"required"`

	// Max Maximum interval in milliseconds.
	Max float32 `json:"max" jsonschema:"Maximum interval in milliseconds." validate:"required"`
}

func (e ExponentialRepeatInterval) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Strategy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Strategy", err)
		}
	}
	if err := typesValidator.Var(e.Min, "required"); err != nil {
		errors = errors.Append("Min", err)
	}
	if err := typesValidator.Var(e.Max, "required"); err != nil {
		errors = errors.Append("Max", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Monitor struct {
	ID                    int64         `json:"id" validate:"required"`
	Name                  string        `json:"name" validate:"required"`
	Type                  MonitorType   `json:"type" validate:"required"`
	Status                MonitorStatus `json:"status" validate:"required"`
	NotifyEveryoneByEmail *bool         `json:"notifyEveryoneByEmail,omitempty"`
	TeamIds               []int         `json:"teamIds,omitempty"`
	ChannelIds            []int         `json:"channelIds,omitempty"`

	// RepeatInterval Monitor repeat interval configuration.
	RepeatInterval *RepeatInterval `json:"repeatInterval,omitempty" jsonschema:"Monitor repeat interval configuration."`
	Params         map[string]any  `json:"params,omitempty"`
	CreatedAt      *float32        `json:"createdAt,omitempty"`
	UpdatedAt      *float32        `json:"updatedAt,omitempty"`
}

func (m Monitor) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(m.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(m.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(m.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(m.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if m.RepeatInterval != nil {
		if v, ok := any(m.RepeatInterval).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RepeatInterval", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Dashboard struct {
	ID             int64                  `json:"id" validate:"required"`
	ProjectID      int64                  `json:"projectId" validate:"required"`
	TemplateID     *string                `json:"templateId,omitempty"`
	Name           string                 `json:"name" validate:"required"`
	Pinned         *bool                  `json:"pinned,omitempty"`
	MinInterval    *float32               `json:"minInterval,omitempty"`
	TimeOffset     *float32               `json:"timeOffset,omitempty"`
	GridQuery      *string                `json:"gridQuery,omitempty"`
	GridMaxWidth   *int                   `json:"gridMaxWidth,omitempty"`
	TableMetrics   []MetricAlias          `json:"tableMetrics,omitempty"`
	TableQuery     *string                `json:"tableQuery,omitempty"`
	TableGrouping  []string               `json:"tableGrouping,omitempty"`
	TableColumnMap map[string]TableColumn `json:"tableColumnMap,omitempty"`
	CreatedAt      *float32               `json:"createdAt,omitempty"`
	UpdatedAt      *float32               `json:"updatedAt,omitempty"`
}

func (d Dashboard) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(d.ProjectID, "required"); err != nil {
		errors = errors.Append("ProjectID", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	for i, item := range d.TableMetrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableMetrics[%d]", i), err)
			}
		}
	}
	for k, v := range d.TableColumnMap {
		if validator, ok := any(v).(runtime.Validator); ok {
			if err := validator.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableColumnMap[%s]", k), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DashboardResponse struct {
	Dashboard Dashboard `json:"dashboard"`
}

func (d DashboardResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Dashboard).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Dashboard", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DashboardTableUpdate struct {
	Name           *string                `json:"name,omitempty"`
	TableMetrics   []MetricAlias          `json:"tableMetrics,omitempty"`
	TableQuery     *string                `json:"tableQuery,omitempty"`
	TableColumnMap map[string]TableColumn `json:"tableColumnMap,omitempty"`
}

func (d DashboardTableUpdate) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.TableMetrics {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableMetrics[%d]", i), err)
			}
		}
	}
	for k, v := range d.TableColumnMap {
		if validator, ok := any(v).(runtime.Validator); ok {
			if err := validator.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TableColumnMap[%s]", k), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MetricAlias struct {
	Name  string `json:"name" validate:"required"`
	Alias string `json:"alias" validate:"required"`
}

func (m MetricAlias) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type TableColumn struct {
	Unit              *string             `json:"unit,omitempty"`
	Color             *string             `json:"color,omitempty"`
	AggFunc           *TableColumnAggFunc `json:"aggFunc,omitempty"`
	SparklineDisabled *bool               `json:"sparklineDisabled,omitempty"`
}

func (t TableColumn) Validate() error {
	var errors runtime.ValidationErrors
	if t.AggFunc != nil {
		if v, ok := any(t.AggFunc).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AggFunc", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridRow struct {
	ID          int64      `json:"id" validate:"required"`
	DashID      int64      `json:"dashId" validate:"required"`
	Title       string     `json:"title" validate:"required"`
	Description *string    `json:"description,omitempty"`
	Expanded    *bool      `json:"expanded,omitempty"`
	Index       int        `json:"index" validate:"required"`
	Items       []GridItem `json:"items,omitempty"`
	CreatedAt   *float32   `json:"createdAt,omitempty"`
	UpdatedAt   *float32   `json:"updatedAt,omitempty"`
}

func (g GridRow) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.DashID, "required"); err != nil {
		errors = errors.Append("DashID", err)
	}
	if err := typesValidator.Var(g.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Index, "required"); err != nil {
		errors = errors.Append("Index", err)
	}
	for i, item := range g.Items {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Items[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridRowRequest struct {
	Title       string  `json:"title" validate:"required"`
	Description *string `json:"description,omitempty"`
	Expanded    *bool   `json:"expanded,omitempty"`
}

func (g GridRowRequest) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GridRowResponse struct {
	GridRow GridRow `json:"gridRow"`
}

func (g GridRowResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.GridRow).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GridRow", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridItem struct {
	ID          int64            `json:"id" validate:"required"`
	Title       string           `json:"title" validate:"required"`
	Description *string          `json:"description,omitempty"`
	DashID      int64            `json:"dashId" validate:"required"`
	DashKind    GridItemDashKind `json:"dashKind" validate:"required"`
	RowID       *int64           `json:"rowId,omitempty"`
	Width       *int             `json:"width,omitempty"`
	Height      *int             `json:"height,omitempty"`
	XAxis       *int             `json:"xAxis,omitempty"`
	YAxis       *int             `json:"yAxis,omitempty"`
	Type        GridItemType     `json:"type" validate:"required"`
	Params      map[string]any   `json:"params,omitempty"`
	CreatedAt   *float32         `json:"createdAt,omitempty"`
	UpdatedAt   *float32         `json:"updatedAt,omitempty"`
}

func (g GridItem) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.DashID, "required"); err != nil {
		errors = errors.Append("DashID", err)
	}
	if v, ok := any(g.DashKind).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DashKind", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridItemRequest struct {
	Title       string                  `json:"title" validate:"required"`
	Description *string                 `json:"description,omitempty"`
	DashKind    GridItemRequestDashKind `json:"dashKind" validate:"required"`
	RowID       int64                   `json:"rowId" validate:"required"`
	Width       *int                    `json:"width,omitempty"`
	Height      *int                    `json:"height,omitempty"`
	XAxis       *int                    `json:"xAxis,omitempty"`
	YAxis       *int                    `json:"yAxis,omitempty"`
	Type        GridItemRequestType     `json:"type" validate:"required"`
	Params      map[string]any          `json:"params,omitempty"`
}

func (g GridItemRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if v, ok := any(g.DashKind).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DashKind", err)
		}
	}
	if err := typesValidator.Var(g.RowID, "required"); err != nil {
		errors = errors.Append("RowID", err)
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GridItemResponse struct {
	GridItem GridItem `json:"gridItem"`
}

func (g GridItemResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.GridItem).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GridItem", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// SlackParams Slack params. When authMethod=webhook, webhookUrl is required. When authMethod=token, token and channel are required.
type SlackParams struct {
	WebhookURL *string                `json:"webhookUrl,omitempty"`
	Token      *string                `json:"token,omitempty"`
	Channel    *string                `json:"channel,omitempty"`
	AuthMethod *SlackParamsAuthMethod `json:"authMethod,omitempty"`
}

func (s SlackParams) Validate() error {
	var errors runtime.ValidationErrors
	if s.AuthMethod != nil {
		if v, ok := any(s.AuthMethod).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AuthMethod", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GoogleChatParams struct {
	WebhookURL string `json:"webhookUrl" validate:"required"`
}

func (g GoogleChatParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type MattermostParams struct {
	WebhookURL string `json:"webhookUrl" validate:"required"`
}

func (m MattermostParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type PagerdutyParams struct {
	RoutingKey string                  `json:"routingKey" validate:"required"`
	Severity   PagerdutyParamsSeverity `json:"severity" validate:"required"`
}

func (p PagerdutyParams) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.RoutingKey, "required"); err != nil {
		errors = errors.Append("RoutingKey", err)
	}
	if v, ok := any(p.Severity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Severity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ServicenowParams struct {
	URL         string                    `json:"url" validate:"required"`
	Username    string                    `json:"username" validate:"required"`
	Password    string                    `json:"password" validate:"required"`
	Category    *string                   `json:"category,omitempty"`
	Subcategory *string                   `json:"subcategory,omitempty"`
	Impact      *ServicenowParamsImpact   `json:"impact,omitempty"`
	Urgency     *ServicenowParamsUrgency  `json:"urgency,omitempty"`
	Severity    *ServicenowParamsSeverity `json:"severity,omitempty"`
	CallerID    *string                   `json:"callerId,omitempty"`
	Group       *string                   `json:"group,omitempty"`
	AssignedTo  *string                   `json:"assignedTo,omitempty"`
	OpenedBy    *string                   `json:"openedBy,omitempty"`
	Notify      *ServicenowParamsNotify   `json:"notify,omitempty"`
	DueDate     *string                   `json:"dueDate,omitempty"`
}

func (s ServicenowParams) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.URL, "required"); err != nil {
		errors = errors.Append("URL", err)
	}
	if err := typesValidator.Var(s.Username, "required"); err != nil {
		errors = errors.Append("Username", err)
	}
	if err := typesValidator.Var(s.Password, "required"); err != nil {
		errors = errors.Append("Password", err)
	}
	if s.Impact != nil {
		if v, ok := any(s.Impact).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Impact", err)
			}
		}
	}
	if s.Urgency != nil {
		if v, ok := any(s.Urgency).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Urgency", err)
			}
		}
	}
	if s.Severity != nil {
		if v, ok := any(s.Severity).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Severity", err)
			}
		}
	}
	if s.Notify != nil {
		if v, ok := any(s.Notify).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Notify", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OpsgenieParams struct {
	APIKey   string                 `json:"apiKey" validate:"required"`
	Priority OpsgenieParamsPriority `json:"priority" validate:"required"`
}

func (o OpsgenieParams) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.APIKey, "required"); err != nil {
		errors = errors.Append("APIKey", err)
	}
	if v, ok := any(o.Priority).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Priority", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TelegramParams struct {
	ChatID int64 `json:"chatId" validate:"required"`
}

func (t TelegramParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TeamsParams struct {
	WebhookURL string `json:"webhookUrl" validate:"required"`
}

func (t TeamsParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type WebhookParams struct {
	URL     string         `json:"url" validate:"required"`
	Payload map[string]any `json:"payload,omitempty"`
}

func (w WebhookParams) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(w))
}

type NotificationChannel struct {
	ID           int64                           `json:"id" validate:"required"`
	ProjectID    int64                           `json:"projectId" validate:"required"`
	Name         string                          `json:"name" validate:"required"`
	Type         NotificationChannelType         `json:"type" validate:"required"`
	Status       NotificationChannelStatus       `json:"status" validate:"required"`
	ErrorData    *string                         `json:"error,omitempty"`
	MatchAll     *bool                           `json:"matchAll,omitempty"`
	Condition    *string                         `json:"condition,omitempty"`
	Priorities   []NotificationChannelPriorities `json:"priorities,omitempty"`
	Params       NotificationChannel_Params      `json:"params"`
	MonitorIds   []int64                         `json:"monitorIds,omitempty"`
	MonitorCount *int                            `json:"monitorCount,omitempty"`
	SentCount    *int                            `json:"sentCount,omitempty"`
	LastSentAt   *time.Time                      `json:"lastSentAt,omitempty"`
}

func (n NotificationChannel) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(n.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(n.ProjectID, "required"); err != nil {
		errors = errors.Append("ProjectID", err)
	}
	if err := typesValidator.Var(n.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(n.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(n.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range n.Priorities {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Priorities[%d]", i), err)
			}
		}
	}
	if v, ok := any(n.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NotificationChannel_Params struct {
	NotificationChannel_Params_OneOf *NotificationChannel_Params_OneOf `json:"-"`
}

func (n NotificationChannel_Params) Validate() error {
	var errors runtime.ValidationErrors
	if n.NotificationChannel_Params_OneOf != nil {
		if v, ok := any(n.NotificationChannel_Params_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NotificationChannel_Params_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NotificationChannel_Params) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NotificationChannel_Params_OneOf)
		if err != nil {
			return nil, fmt.Errorf("NotificationChannel_Params_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NotificationChannel_Params) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NotificationChannel_Params_OneOf == nil {
		n.NotificationChannel_Params_OneOf = &NotificationChannel_Params_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NotificationChannel_Params_OneOf); err != nil {
		return fmt.Errorf("NotificationChannel_Params_OneOf unmarshal: %w", err)
	}

	return nil
}

type NotificationChannelRequest struct {
	Name       string                                 `json:"name" validate:"required"`
	Type       NotificationChannelRequestType         `json:"type" validate:"required"`
	MatchAll   *bool                                  `json:"matchAll,omitempty"`
	MonitorIds []int64                                `json:"monitorIds,omitempty"`
	Condition  *string                                `json:"condition,omitempty"`
	Priorities []NotificationChannelRequestPriorities `json:"priorities" validate:"required"`
	Params     NotificationChannelRequest_Params      `json:"params"`
}

func (n NotificationChannelRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(n.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(n.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	for i, item := range n.Priorities {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Priorities[%d]", i), err)
			}
		}
	}
	if v, ok := any(n.Params).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Params", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NotificationChannelRequest_Params struct {
	NotificationChannelRequest_Params_OneOf *NotificationChannelRequest_Params_OneOf `json:"-"`
}

func (n NotificationChannelRequest_Params) Validate() error {
	var errors runtime.ValidationErrors
	if n.NotificationChannelRequest_Params_OneOf != nil {
		if v, ok := any(n.NotificationChannelRequest_Params_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NotificationChannelRequest_Params_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NotificationChannelRequest_Params) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NotificationChannelRequest_Params_OneOf)
		if err != nil {
			return nil, fmt.Errorf("NotificationChannelRequest_Params_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NotificationChannelRequest_Params) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NotificationChannelRequest_Params_OneOf == nil {
		n.NotificationChannelRequest_Params_OneOf = &NotificationChannelRequest_Params_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NotificationChannelRequest_Params_OneOf); err != nil {
		return fmt.Errorf("NotificationChannelRequest_Params_OneOf unmarshal: %w", err)
	}

	return nil
}

type NotificationChannelResponse struct {
	Channel NotificationChannel `json:"channel"`
}

func (n NotificationChannelResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.Channel).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Channel", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}
